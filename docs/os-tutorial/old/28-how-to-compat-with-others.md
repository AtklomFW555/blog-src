前面我们花费了 26 节（刨去没有实质内容的第 25 节），实现了一个简单的操作系统内核；而如今，我们将会给予它更多的能力。

近来（其实已经很早了）常见到有华为 HarmonyOS 与安卓开源项目 AOSP 之争，一部分人指出 HarmonyOS 并非完全自主而是基于 AOSP 来实现，另一部分人则争辩道 HarmonyOS 只是“兼容” AOSP，而“不是” AOSP。哪方正确哪方错误我们且先不论，背后可有外国资助我们暂且不谈，今天我们的任务，就是来“兼容”另外一个操作系统的程序。

那么，该兼容哪个呢？在谈论这个话题之前，更应该谈清楚的一件事情是：何为兼容？

假设有一个 A 操作系统和一个 B 操作系统，现在 A 操作系统要去兼容 B 操作系统。这一般意味着，B 操作系统上的应用程序要以某种形式在 A 操作系统上能够不加修改地运行，且效果不变（不然的话兼容可太简单了）。兼容也分级别，高级点的是二进制级别的兼容，也就是在 B 操作系统上写好的程序不用做任何修改，可以直接在 A 操作系统上运行，且效果与原来别无二致；再低一点的是源码级别的兼容，也就是在 B 操作系统上写好的程序虽然不能直接在 A 操作系统上运行，但它的源代码可以直接在 A 操作系统上编译，并且编译出来的程序的运行效果与 B 操作系统上一致。

既然有这么一个定义了，我们自然追求高标准，要实现二进制级别的兼容。在此之前，先看看目前主流电脑操作系统的兼容状况：

Windows、macOS 和 Linux 可执行文件格式两两不同，完美的二进制级兼容遥遥无期（Linux 上的应用程序需要借 WSL 的手才能在 Windows 上完整执行，而 WSL2 本质上相当于模拟了一个 Linux 出来，实质上还是 Linux 应用程序在 Linux 上跑，故不能算作二进制级兼容；Linux 上的 wine 虽然不是虚拟机，但并不是所有的应用程序 wine 都支持，故亦不能算作完美的二进制级兼容）。由于 C 语言成为各大操作系统的事实标准，上述系统之间的源码级兼容较为直接，但也并非完全（Windows 上没有 fork，macOS 与 Linux 的细节不同等等）。

看来，想要抄作业怕是有难了，最接近二进制级别兼容的也就是 wine。wine 的思路非常简单：第一步，实现带 dll 的 exe 程序的执行（所有在 Windows 下能执行的 exe 程序基本都依赖 dll，只有少数除外）；第二步，用 Linux 上的工具实现所有 Windows API，并编译成几个常规 exe 依赖的 dll。这样，exe 能通过第一步的操作找到 dll，又能通过第二步的操作在 dll 里找到对应的功能并进行完美实现，不就相当于能够完美执行 exe 了么？

前面已经提到，目前大部分自制操作系统内核的可执行文件格式都是 ELF，小部分使用 PE 的目前还没见到哪个支持应用程序（如果有，一般也就是奔着兼容 Windows 去了，那样我可吃不消）。如果要兼容别的 ELF，那就相当于跳过了上面的第一步，直接执行第二步，总感觉少了点什么。因此，我们选择兼容自制可执行文件格式的典范（大嘘）之作：《30天自制操作系统》里的 HariboteOS！

HariboteOS 的可执行文件大都经过压缩，其细节繁复，本节不打算支持。??这样一看，其实我们所做的也不是完美的二进制级别的兼容，毕竟把压缩过的东西丢过来是不能直接运行的嘛。?? 同时，HariboteOS 还是一个 GUI 操作系统，虽然 GUI 相关的 API 不多，但 GUI 应用程序很多，再加上 QEMU 还不支持蜂鸣器，还有一些程序显示的是日文，因此到最后，能够完美兼容的应用程序也就那么几个。

具体而言，HariboteOS 共有应用 29 个，命令行程序只有 12 个，其中能够完美兼容的程序更是只有 10 个（`iroha` 输出均为日文无法兼容，`beepdown` 因为 QEMU 不支持蜂鸣器无法兼容），占到 HariboteOS 全部应用程序的 34%；如果把效果基本类似的 sosu、sosu2、sosu3 当成一个程序，hello3、hello4、hello5 当成一个程序，那就要再砍掉 4 个，变成 6 个，这一比例则进一步下降到 24%。??这下成标题党了。?? 如果我们真的要追求极致的完美，那就只能想办法从文本模式中脱离出去，进入 GUI 模式当中。

能够完整在保护模式下实现且不依赖虚拟机的方法，基本上只能进入 320 * 200 的 GUI 模式，但这还不够 `bball.hrb` 用，更别提可以调窗口大小的 `tview.hrb`。而如果想要进入更高分辨率的 GUI 模式，只有一下三条路可走：

1. 实现一个 8086 虚拟机，然后手动设置好 8086 虚拟机的寄存器，让 8086 虚拟机去跑 `int 10h` 对应的那段代码。这样做可不可以？当然可以，太可以了。但独立实现一个 8086 虚拟机明显超乎我们的能力，网上抄的又难以集成到操作系统环境下。

2. 使用保护模式的独有特性——虚拟 8086 模式（这一功能在 64 位被砍了，64 位没有保护模式）。大致流程如下：第一步，创建一个任务，设置它 eflags 的 VM 位为 1（任务切换是进入和退出虚拟 8086 模式的唯一方法）；第二步，在这个已经进入虚拟 8086 模式的程序里写一段 16 位代码，大致内容就是等待用户的中断请求（可以通过循环检测内存之类的方式实现）——如果有请求了就执行中断——否则就一直等下去；第三步，虚拟 8086 模式依靠一般保护性异常（13 号异常）驱动，因此要特别关照 13 号异常的处理程序，如果判定此异常由这个虚拟 8086 任务触发，就手动执行对应的 16 位指令（我们只需要执行和栈有关的即可），原先处理器的栈平衡问题现在都交给你来处理。这一条路或许可以走通，但看着就麻烦，??笔者自己尝试还失败了，中断能执行，但只能执行一部分，而且没法进入图形模式，??因此也不走。

3. 返回实模式，执行完中断请求以后再回到保护模式。